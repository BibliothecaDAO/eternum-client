/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 public/models/world_map.glb --transform
*/

import React, { useEffect, useRef } from 'react'
import { useGLTF, GradientTexture} from '@react-three/drei'
import { useControls, button } from 'leva';
import { Water } from 'three/addons/objects/Water2.js';
import * as THREE from 'three';

const WaterModel = () => {
  const params = {
    color: '#ffffff',
    scale: 5,
    flowX: 1,
    flowY: 1
  };

  const waterGeometry = new THREE.PlaneGeometry( 4, 4 );
  const textureLoader = new THREE.TextureLoader();
  const flowMap = textureLoader.load( 'textures/water/Water_1_M_Flow.jpg' );

  let water = new Water( waterGeometry, {
    color: params.color,
    scale: params.scale,
    flowMap: flowMap,
    textureWidth: 1024,
    textureHeight: 1024
  } );
  return (
    <primitive object={water}
      rotation={[-Math.PI / 2, 0, 0]}
      position={[0, 0.001, 0]}
    />
  )
}
export function Model(props) {
  const { nodes, materials } = useGLTF('/models/world_map_13-transformed.glb')
  const { worldmapPosition, worldmapScale, metalness, roughness } = useControls({
      worldmapPosition:
      {
          value: { x: 0, z: 0, y: 0 },
          step: 0.01
      },
      worldmapScale:
      {
          value: 201.05,
          step: 0.05
      },
      metalness:
      {
          value: 0.63,
          step: 0.001,
          max: 1,
          min: 0
      },
      roughness:
      {
          value: 0.71,
          step: 0.001,
          max: 1,
          min: 0
      }
  })

  const color = new THREE.Color( 0xffffff );

  const targetGeometry = nodes.continents.geometry

  const gradient = [
    '#fafafa',
    '#ebd09b',
    '#42613e',
    '#778741',
    '#fafafa',
    '#fafafa',
    ]
  const geometryColors = new Float32Array( targetGeometry.attributes.position.count * 3 );

  useEffect(() => {
    let maxYPosition = 0
    let minYPosition = 0
    for ( let i = 0; i < geometryColors.length; i += 3 ) {
      const yPosition = targetGeometry.attributes.position.array[i + 1];
      if (yPosition > maxYPosition) {
        maxYPosition = yPosition;
      }
      if (yPosition < minYPosition) {
        minYPosition = yPosition;
      }
    }
  
    for ( let i = 0; i < geometryColors.length; i += 3 ) {
      const yPosition = targetGeometry.attributes.position.array[i + 1];
      const colorIndex = Math.floor( (yPosition - minYPosition) / (maxYPosition - minYPosition) * (gradient.length - 1) );
      color.set( gradient[colorIndex] );
      geometryColors[i] = color.r;
      geometryColors[i + 1] = color.g;
      geometryColors[i + 2] = color.b;
    }
    targetGeometry.setAttribute( 'color', new THREE.BufferAttribute( geometryColors, 3 ) );
  }, [])

  return (<>      
    <group {...props} dispose={null} scale={[worldmapScale, worldmapScale, worldmapScale]} position={[worldmapPosition.x, worldmapPosition.y, worldmapPosition.z]}>
      {/* <WaterModel />
      <mesh geometry={nodes.ocean.geometry} material={materials.Ocean} position={[0,-0.01,0]} scale={[3, 1, 3]} />
      <mesh geometry={nodes.realms_worldTextures_topography_3002.geometry}>
        <meshStandardMaterial flatShading vertexColors metalness={metalness} roughness={roughness}>
        </meshStandardMaterial>
      </mesh> */}
      <mesh geometry={nodes.continents.geometry}>
      <meshStandardMaterial flatShading vertexColors metalness={metalness} roughness={roughness}>
        </meshStandardMaterial>
        </mesh>
    </group>
    </>
  )
}

useGLTF.preload('/models/world_map_13-transformed.glb')
